// ===== CONFIG =====
const DEFAULT_CENTER = [10.776, 106.7];
const MIN_ZOOM_FOR_STOPS = 16;

const HCMC_BBOX = { south: 10.3, west: 106.35, north: 11.2, east: 107.05 };

const GRID_STEP = 0.3;
const GRID_CONCURRENCY = 1;

const OVERPASS_ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.kumi.systems/api/interpreter",
  "https://overpass.nchc.org.tw/api/interpreter",
  "https://overpass.openstreetmap.ru/api/interpreter",
];

// ===== STATE =====
const state = {
  map: null,
  markers: [],
  drawnIds: new Set(),
  stationsInView: [],
  masterStations: [],
  masterReady: false,
  routes: [],
  lastViewKey: null,
  tempMarker: null,
  myMarker: null,
};

// ===== BOOT =====
window.addEventListener("DOMContentLoaded", async () => {
  state.map = L.map("map").setView(DEFAULT_CENTER, 12);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "¬© OpenStreetMap",
  }).addTo(state.map);
  setTimeout(() => state.map.invalidateSize(), 150);

  bindUI();
  loadRoutes();

  prefetchAllStopsInHCM().catch(console.error);
  await tryCenterToUser();

  const debounced = debounce(onViewChanged, 600);
  state.map.on("moveend", debounced);
  onViewChanged();
});

// ===== UI =====
function bindUI() {
  const panels = {
    stations: qs("#panel-stations"),
    routes: qs("#panel-routes"),
  };
  qsa(".mode-btn").forEach((btn) => {
    const m = btn.dataset.mode;
    if (!m) return;
    btn.addEventListener("click", () => {
      Object.entries(panels).forEach(([k, v]) =>
        v.classList.toggle("hidden", k !== m)
      );
      qsa(".mode-btn[data-mode]").forEach((b) =>
        b.classList.toggle("active", b.dataset.mode === m)
      );
    });
  });

  on("#locateMe", "click", locateMe);
  on("#searchBtn", "click", () => globalSearch(qs("#globalSearch").value));
  on("#globalSearch", "keydown", (e) => {
    if (e.key === "Enter") globalSearch(e.target.value);
  });

  on("#stationFilter", "input", (e) =>
    renderStationList(filterByName(state.stationsInView, e.target.value))
  );
  on("#routeFilter", "input", (e) =>
    renderRouteList(filterByRoute(state.routes, e.target.value))
  );
}

// ===== GLOBAL SEARCH =====
async function globalSearch(raw) {
  const q = (raw || "").trim().toLowerCase();
  if (!q) return;
  if (!state.masterReady)
    toast("Ch·ªâ m·ª•c to√†n TP.HCM ƒëang n·∫°p‚Ä¶ s·∫Ω ƒë·∫ßy ƒë·ªß sau √≠t gi√¢y.");

  const hits = (state.masterStations || []).filter((s) =>
    (s.name || "").toLowerCase().includes(q)
  );
  if (hits.length) {
    const s = hits[0];
    flyToStation(s, true);
    renderStationList(hits.slice(0, 200));
    qs("#stationFilter").value = raw;
    return;
  }

  try {
    const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&countrycodes=vn&q=${encodeURIComponent(
      raw
    )}`;
    const res = await fetch(url, { headers: { "Accept-Language": "vi" } });
    const data = await res.json();
    if (!data.length)
      return toast("Kh√¥ng t√¨m th·∫•y tr·∫°m ho·∫∑c ƒë·ªãa ƒëi·ªÉm ph√π h·ª£p.");
    const { lat, lon } = data[0];
    if (!pointInHCM(+lat, +lon))
      toast("ƒêi·ªÉm t√¨m ƒë∆∞·ª£c ngo√†i TP.HCM ‚Äî ƒëang ƒë∆∞a b·∫°n ƒë·∫øn v·ªã tr√≠ ƒë√≥.");
    state.map.setView(
      [+lat, +lon],
      Math.max(state.map.getZoom(), MIN_ZOOM_FOR_STOPS)
    );
    onViewChanged();
  } catch (e) {
    console.warn("Geocode error:", e);
    toast("Kh√¥ng th·ªÉ geocode ƒë·ªãa danh l√∫c n√†y.");
  }
}

// ===== VIEW CHANGE =====
async function onViewChanged() {
  if (state.map.getZoom() < MIN_ZOOM_FOR_STOPS) {
    clearMarkersAndList(
      "Zoom ‚â• " +
        MIN_ZOOM_FOR_STOPS +
        " ƒë·ªÉ hi·ªÉn th·ªã marker tr·∫°m trong khung nh√¨n."
    );
    return;
  }
  const b = state.map.getBounds();
  if (!bboxIntersects(b, HCMC_BBOX)) {
    clearMarkersAndList(
      "Ngo√†i ph·∫°m vi TP.HCM. K√©o b·∫£n ƒë·ªì v√†o TP.HCM ƒë·ªÉ hi·ªÉn th·ªã tr·∫°m."
    );
    return;
  }
  const key = bboxKey(b);
  if (key === state.lastViewKey) return;
  state.lastViewKey = key;

  await loadStopsInBBox(b);
}

function clearMarkersAndList(message) {
  state.markers.forEach((m) => state.map.removeLayer(m));
  state.markers = [];
  state.drawnIds.clear();
  state.stationsInView = [];
  renderStationList([]);
  qs("#stationList").innerHTML = `<div class="item small">${message}</div>`;
}

// ===== GEOLOCATION (no alerts) =====
async function tryCenterToUser() {
  if (!navigator.geolocation) return false;
  return new Promise((resolve) => {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude: lat, longitude: lng } = pos.coords;
        if (pointInHCM(lat, lng)) {
          state.map.setView([lat, lng], Math.max(14, MIN_ZOOM_FOR_STOPS));
          if (state.myMarker) state.map.removeLayer(state.myMarker);
          state.myMarker = L.marker([lat, lng], {
            title: "V·ªã tr√≠ c·ªßa t√¥i",
            icon: L.icon({
              iconUrl:
                "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
              shadowUrl:
                "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41],
            }),
          })
            .addTo(state.map)
            .bindPopup("üìç ƒê√¢y l√† v·ªã tr√≠ c·ªßa t√¥i")
            .openPopup();
        }
        resolve(true);
      },
      (_) => resolve(false),
      { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
    );
  });
}

function locateMe() {
  if (!navigator.geolocation) {
    toast("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã.");
    return;
  }
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const { latitude: lat, longitude: lng } = pos.coords;
      if (!pointInHCM(lat, lng)) toast("V·ªã tr√≠ hi·ªán t·∫°i ngo√†i TP.HCM.");
      state.map.setView([lat, lng], Math.max(14, MIN_ZOOM_FOR_STOPS));
      onViewChanged();
      if (state.myMarker) state.map.removeLayer(state.myMarker);
      state.myMarker = L.marker([lat, lng], {
        title: "V·ªã tr√≠ c·ªßa t√¥i",
        icon: L.icon({
          iconUrl:
            "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
          shadowUrl:
            "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
        }),
      })
        .addTo(state.map)
        .bindPopup("üìç ƒê√¢y l√† v·ªã tr√≠ c·ªßa t√¥i")
        .openPopup();
      toast("üìç ƒê√£ c·∫≠p nh·∫≠t v·ªã tr√≠ th√†nh c√¥ng");
    },
    (err) => {
      console.warn("Geolocation error:", err);
      // Kh√¥ng hi·ªán alert ‚Äî ch·ªâ nh·∫Øc nh·∫π
      toast("Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i, th·ª≠ l·∫°i sau.");
    },
    { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
  );
}

// ===== CACHE =====
const OSM_CACHE_TTL_MS = 24 * 60 * 60 * 1000;
const osmMemCache = new Map();
function cacheKeyFromQuery(q) {
  return "osm_cache_" + q.replace(/\s+/g, " ").trim();
}
function getCache(q) {
  const k = cacheKeyFromQuery(q),
    now = Date.now();
  const mem = osmMemCache.get(k);
  if (mem && now - mem.t <= OSM_CACHE_TTL_MS) return mem.v;
  try {
    const raw = localStorage.getItem(k);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (now - obj.t <= OSM_CACHE_TTL_MS) {
      osmMemCache.set(k, obj);
      return obj.v;
    }
    localStorage.removeItem(k);
  } catch {}
  return null;
}
function setCache(q, v) {
  const k = cacheKeyFromQuery(q),
    obj = { t: Date.now(), v };
  osmMemCache.set(k, obj);
  try {
    localStorage.setItem(k, JSON.stringify(obj));
  } catch {}
}

// ===== OVERPASS (round-robin + retry/backoff) =====
let overpassIdx = 0;
function nextOverpassEndpoint() {
  const url = OVERPASS_ENDPOINTS[overpassIdx % OVERPASS_ENDPOINTS.length];
  overpassIdx++;
  return url;
}
function respectRetryAfterMs(res) {
  const ra = res.headers.get("Retry-After");
  if (!ra) return 0;
  const n = Number(ra);
  return Number.isNaN(n) ? 0 : n * 1000;
}
function jitter(ms) {
  return ms + Math.random() * Math.min(400, ms * 0.25);
}

async function overpass(query, { retries = 4, signal } = {}) {
  const cached = getCache(query);
  if (cached) return cached;

  let attempt = 0,
    lastErr = null;
  while (attempt <= retries) {
    const endpoint = nextOverpassEndpoint();
    try {
      const res = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        },
        body: "data=" + encodeURIComponent(query),
        signal,
      });
      if (res.status === 429 || res.status === 504 || res.status === 502) {
        const waitRa = respectRetryAfterMs(res);
        const backoff = jitter(Math.min(8000, 500 * 2 ** attempt));
        await sleep(Math.max(waitRa, backoff));
        attempt++;
        continue;
      }
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      setCache(query, data);
      return data;
    } catch (e) {
      lastErr = e;
      if (e.name === "AbortError") throw e;
      const backoff = jitter(Math.min(8000, 500 * 2 ** attempt));
      await sleep(backoff);
      attempt++;
    }
  }
  throw lastErr || new Error("Overpass failed");
}

// ===== BBOX LOADING (with guard) =====
let bboxLoading = false;
let bboxAborter = null;
async function loadStopsInBBox(bounds) {
  if (bboxLoading) return;
  bboxLoading = true;
  if (bboxAborter) bboxAborter.abort();
  bboxAborter = new AbortController();

  const { south, west, north, east } = toFixedBBox(bounds);
  const query = `
    [out:json][timeout:25];
    (
      node["highway"="bus_stop"](${south},${west},${north},${east});
      node["public_transport"="platform"](${south},${west},${north},${east});
    );
    out body;`;

  try {
    showLoading(true);
    const data = await overpass(query, { signal: bboxAborter.signal });
    const stops = (data.elements || [])
      .filter((el) => el.type === "node")
      .map((el) => ({
        id: el.id,
        name: el.tags?.name || el.tags?.["name:vi"] || "Tr·∫°m kh√¥ng t√™n",
        lat: el.lat,
        lng: el.lon,
      }));
    state.stationsInView = dedupById(stops);
    renderStationsOnMap(state.stationsInView);
    renderStationList(state.stationsInView);
  } catch (e) {
    console.warn("BBOX load error:", String(e));
    toast(
      "Kh√¥ng t·∫£i ƒë∆∞·ª£c tr·∫°m (c√≥ th·ªÉ b·ªã gi·ªõi h·∫°n t·∫°m th·ªùi). Th·ª≠ l·∫°i sau √≠t gi√¢y."
    );
  } finally {
    showLoading(false);
    bboxLoading = false;
  }
}

// ===== PREFETCH MASTER =====
async function prefetchAllStopsInHCM() {
  const tiles = buildTiles(HCMC_BBOX, GRID_STEP);
  let done = 0;
  const idSet = new Set();
  const all = [];
  while (done < tiles.length) {
    const batch = tiles.slice(done, done + GRID_CONCURRENCY);
    await Promise.all(
      batch.map(async (t) => {
        const query = `
        [out:json][timeout:25];
        (
          node["highway"="bus_stop"](${t.s},${t.w},${t.n},${t.e});
          node["public_transport"="platform"](${t.s},${t.w},${t.n},${t.e});
        );
        out body;`;
        try {
          const data = await overpass(query);
          for (const el of data.elements || []) {
            if (el.type !== "node") continue;
            if (idSet.has(el.id)) continue;
            idSet.add(el.id);
            all.push({
              id: el.id,
              name: el.tags?.name || el.tags?.["name:vi"] || "Tr·∫°m kh√¥ng t√™n",
              lat: el.lat,
              lng: el.lon,
            });
          }
        } catch (e) {
          console.warn(
            "Tile l·ªói (s·∫Ω b·ªè qua):",
            `${t.s},${t.w},${t.n},${t.e}`,
            String(e)
          );
        }
      })
    );
    done += batch.length;
    updateMasterProgress(done, tiles.length, all.length);
    await sleep(300);
  }
  state.masterStations = all;
  state.masterReady = true;
  qs("#masterCount").textContent = `${all.length.toLocaleString("vi-VN")} tr·∫°m`;
  qs("#masterProgress").textContent = `xong (${all.length.toLocaleString(
    "vi-VN"
  )} tr·∫°m)`;
}

// ===== RENDER =====
function renderStationsOnMap(stations) {
  state.markers.forEach((m) => state.map.removeLayer(m));
  state.markers = [];
  state.drawnIds.clear();
  stations.forEach((s) => {
    if (state.drawnIds.has(s.id)) return;
    const m = L.marker([s.lat, s.lng])
      .addTo(state.map)
      .bindPopup(
        `<b>${escapeHTML(s.name)}</b><br/><span class="small">OSM id: ${
          s.id
        }</span>`
      );
    state.markers.push(m);
    state.drawnIds.add(s.id);
  });
}
function renderStationList(stations) {
  const list = qs("#stationList");
  list.innerHTML = "";
  if (!stations.length) {
    list.innerHTML = `<div class="item small">Kh√¥ng c√≥ tr·∫°m ƒë·ªÉ hi·ªÉn th·ªã.</div>`;
    return;
  }
  stations.forEach((s) => {
    const el = document.createElement("div");
    el.className = "item";
    el.innerHTML = `<b>${escapeHTML(
      s.name
    )}</b><br/><span class="small">${s.lat.toFixed(5)}, ${s.lng.toFixed(
      5
    )}</span>`;
    el.addEventListener("click", () => flyToStation(s, true));
    list.appendChild(el);
  });
}
function flyToStation(s, highlight = false) {
  state.map.setView([s.lat, s.lng], Math.max(17, MIN_ZOOM_FOR_STOPS));
  let marker = state.markers.find((m) => {
    const ll = m.getLatLng();
    return Math.abs(ll.lat - s.lat) < 1e-6 && Math.abs(ll.lng - s.lng) < 1e-6;
  });
  if (!marker && highlight) {
    if (state.tempMarker) state.map.removeLayer(state.tempMarker);
    state.tempMarker = L.marker([s.lat, s.lng], { title: s.name })
      .addTo(state.map)
      .bindPopup(
        `<b>${escapeHTML(
          s.name
        )}</b><br/><span class="small">T·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm</span>`
      )
      .openPopup();
  } else {
    marker && marker.openPopup();
  }
}

// ===== ROUTES (demo) =====
const ROUTES_SEED = [
  ["01", "B·∫øn Th√†nh - BX Ch·ª£ L·ªõn"],
  ["02", "B·∫øn Th√†nh - BX Mi·ªÅn T√¢y"],
  ["03", "B·∫øn Th√†nh - Th·∫°nh L·ªôc"],
  ["04", "B·∫øn Th√†nh - C·ªông H√≤a - An S∆∞∆°ng"],
  ["05", "BX Ch·ª£ L·ªõn - Bi√™n H√≤a"],
  ["06", "BX Ch·ª£ L·ªõn - ƒêH N√¥ng L√¢m"],
  ["07", "BX Ch·ª£ L·ªõn - G√≤ V·∫•p"],
  ["08", "BX Qu·∫≠n 8 - ƒêH Qu·ªëc Gia"],
  ["09", "Ch·ª£ L·ªõn - B√¨nh Ch√°nh - H∆∞ng Long"],
  ["10", "ƒêH Qu·ªëc Gia - BX Mi·ªÅn T√¢y"],
  ["11", "B·∫øn Th√†nh - ƒê·∫ßm Sen"],
  ["12", "B·∫øn Th√†nh - Th√°c Giang ƒêi·ªÅn"],
  ["13", "B·∫øn Th√†nh - BX C·ªß Chi"],
  ["14", "Mi·ªÅn ƒê√¥ng - 3/2 - Mi·ªÅn T√¢y"],
  ["15", "B·∫øn Ph√∫ ƒê·ªãnh - ƒê·∫ßm Sen"],
  ["16", "BX Ch·ª£ L·ªõn - BX T√¢n Ph√∫"],
  ["17", "BX Ch·ª£ L·ªõn - ƒêH S√†i G√≤n - KCX T√¢n Thu·∫≠n"],
  ["18", "B·∫øn Th√†nh - Ch·ª£ Hi·ªáp Th√†nh"],
  ["19", "B·∫øn Th√†nh - KCX Linh Trung - ƒêHQG"],
  ["20", "B·∫øn Th√†nh - Nh√† B√®"],
  ["22", "BX Qu·∫≠n 8 - KCN L√™ Minh Xu√¢n"],
];
function loadRoutes() {
  state.routes = ROUTES_SEED.map(([id, name]) => ({ id, name }));
  renderRouteList(state.routes);
}
function filterByRoute(arr, q) {
  q = (q || "").toLowerCase();
  if (!q) return arr;
  return arr.filter(
    (r) =>
      r.id.toLowerCase().includes(q) || (r.name || "").toLowerCase().includes(q)
  );
}
function renderRouteList(routes) {
  const list = qs("#routeList");
  qs("#routeCount").textContent = routes.length;
  list.innerHTML = "";
  routes.forEach((r) => {
    const el = document.createElement("div");
    el.className = "item";
    el.innerHTML = `<span class="badge">${r.id}</span> &nbsp; ${escapeHTML(
      r.name
    )}`;
    list.appendChild(el);
  });
}

// ===== HELPERS =====
function qs(s) {
  return document.querySelector(s);
}
function qsa(s) {
  return Array.from(document.querySelectorAll(s));
}
function on(sel, ev, fn) {
  qs(sel).addEventListener(ev, fn);
}
function debounce(fn, ms) {
  let t;
  return (...a) => {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(null, a), ms);
  };
}
function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
function escapeHTML(s) {
  return String(s).replace(
    /[&<>"'`=\/]/g,
    (c) =>
      ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;",
      }[c])
  );
}
function dedupById(arr) {
  const seen = new Set(),
    out = [];
  for (const a of arr) {
    if (!seen.has(a.id)) {
      seen.add(a.id);
      out.push(a);
    }
  }
  return out;
}
function showLoading(on) {
  qs("#loading").style.display = on ? "block" : "none";
}
function bboxKey(b) {
  return [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()]
    .map((x) => x.toFixed(4))
    .join(",");
}
function toFixedBBox(bounds) {
  return {
    south: bounds.getSouth().toFixed(6),
    west: bounds.getWest().toFixed(6),
    north: bounds.getNorth().toFixed(6),
    east: bounds.getEast().toFixed(6),
  };
}
function bboxIntersects(b, box) {
  const s = b.getSouth(),
    w = b.getWest(),
    n = b.getNorth(),
    e = b.getEast();
  const is = Math.max(s, box.south),
    iw = Math.max(w, box.west),
    inr = Math.min(n, box.north),
    ie = Math.min(e, box.east);
  return is < inr && iw < ie;
}
function pointInHCM(lat, lng) {
  return (
    lat >= HCMC_BBOX.south &&
    lat <= HCMC_BBOX.north &&
    lng >= HCMC_BBOX.west &&
    lng <= HCMC_BBOX.east
  );
}
function buildTiles(box, step) {
  const tiles = [];
  for (let s = box.south; s < box.north; s += step) {
    for (let w = box.west; w < box.east; w += step) {
      const n = Math.min(s + step, box.north),
        e = Math.min(w + step, box.east);
      tiles.push({
        s: +s.toFixed(5),
        w: +w.toFixed(5),
        n: +n.toFixed(5),
        e: +e.toFixed(5),
      });
    }
  }
  return tiles;
}
function updateMasterProgress(done, total, count) {
  const pct = Math.round((done / total) * 100);
  qs("#masterProgress").textContent = `${pct}%`;
  qs("#masterCount").textContent = `${count.toLocaleString("vi-VN")} tr·∫°m`;
}

// Simple toast
let toastTimer = null;
function toast(msg) {
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.classList.remove("hidden");
  el.classList.add("show");
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    el.classList.remove("show");
  }, 2500);
}
